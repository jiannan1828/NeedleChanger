        public double dbapiIAI(double dbIncreaseGate)  //IAI
        {
            double dbRstIAI = 0.0;

            {  //工作門 讀取與顯示
                int rslt = 0;

                //讀取 工作門 資訊
                byte[] aGetGetIAI = new byte[2];
                clsServoControlWMX3.WMX3_GetInIO(ref aGetGetIAI, (int)(addr_IAI.pxeaI_GetStatusSignal2_2Bytes) / 10, 2);
                rslt += ((aGetGetIAI[(int)(addr_IAI.pxeaI_GetServoONState - addr_IAI.pxeaI_GetStatusSignal2_2Bytes) / 10] & (1 << (int)(addr_IAI.pxeaI_GetServoONState) % 10)) != 0) ? 1 : 0;

                byte[] aGetSetIAI = new byte[2];
                clsServoControlWMX3.WMX3_GetOutIO(ref aGetSetIAI, (int)(addr_IAI.pxeaI_SetControlSignal2_2Bytes) / 10, 2);
                rslt += ((aGetSetIAI[(int)(addr_IAI.pxeaI_SetDisableBrake - addr_IAI.pxeaI_SetControlSignal2_2Bytes) / 10] & (1 << (int)(addr_IAI.pxeaI_SetDisableBrake) % 10)) != 0) ? 1 : 0;

                //計算讀取長度
                int iIAIpos = clsServoControlWMX3.WMX3_IAI(addr_IAI.pxeaI_GetPosition, 0);
                double dbIAIpos = 0.0;
                if (rslt == 2)
                {
                    dbIAIpos = iIAIpos / 100;
                    dbRstIAI = dbIAIpos;
                }

                //顯示運動速度
                int iIAIspd = clsServoControlWMX3.WMX3_IAI(addr_IAI.pxeaI_GetCurrentSpeed4Bytes, 0);
                double dbIAIspd = 0.0;
                if (rslt == 2)
                {
                    dbIAIspd = iIAIspd / 100;
                }

                //變更顏色
                if (rslt == 2)
                {
                    select_IAI.BackColor = Color.Red;
                    lbl_acpos_IAI.BackColor = Color.White;
                    lbl_spd_IAI.BackColor = Color.White;
                }
                else
                {
                    select_IAI.BackColor = Color.Green;
                    lbl_acpos_IAI.BackColor = Color.Gray;
                    lbl_spd_IAI.BackColor = Color.Gray;
                }

                //顯示資訊
                lbl_acpos_IAI.Text = dbIAIpos.ToString("F3");
                lbl_spd_IAI.Text = dbIAIspd.ToString("F3");

                //bshow_debug_RAW_Conver_Back_Value
                lbl_IAI_RAW.Visible = bshow_debug_RAW_Conver_Back_Value;
                lbl_IAI_Convert.Visible = bshow_debug_RAW_Conver_Back_Value;
                lbl_IAI_Back.Visible = bshow_debug_RAW_Conver_Back_Value;
                if (bshow_debug_RAW_Conver_Back_Value == true)
                {
                    lbl_IAI_RAW.Text = iIAIpos.ToString();
                    lbl_IAI_Convert.Text = dbIAIpos.ToString("F3");
                    lbl_IAI_Back.Text = ((int)(dbIAIpos * 100)).ToString();
                }

            }

            if (dbIncreaseGate == dbRead)
            {
                //this.Text = "Z軸尚未回到上位";
            }
            else
            {  //IAI 變更位置
                // 取得欲變更的的浮點數
                double fChangeGate = dbIncreaseGate;

                //伸長量overflow保護
                //if (fChangeGate >= 40.35)
                //{
                //    fChangeGate = 40.35;
                //}

                clsServoControlWMX3.WMX3_IAI(addr_IAI.pxeaI_BrakeOff, 1);

                //執行移動工作門
                clsServoControlWMX3.WMX3_IAI(addr_IAI.pxeaI_MotorOn, 1);
                clsServoControlWMX3.WMX3_IAI(addr_IAI.pxeaI_GoToPosition, fChangeGate);
            }

            return dbRstIAI;
        }  // end of public double dbapiGate(double dbIncreaseGate)  //IAI
